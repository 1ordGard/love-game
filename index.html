<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Ğ”Ğ»Ñ Ğ¼Ğ¾ĞµĞ¹ Ğ»ÑĞ±Ğ¸Ğ¼Ğ¾Ğ¹</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; overflow: hidden;
      -webkit-overflow-scrolling: touch;
      background: linear-gradient(270deg, #ffd6e8, #ffe6cc, #d1c4e9);
      background-size: 600% 600%;
      animation: gradientShift 20s ease infinite;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    @keyframes gradientShift {
      0%   { background-position:   0% 50%; }
      50%  { background-position: 100% 50%; }
      100% { background-position:   0% 50%; }
    }
    canvas {
      position: absolute; top: 0; left: 0;
      background: transparent;
      -webkit-user-drag: none;
    }
    #message {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      font-family: 'Press Start 2P', cursive;
      font-size: 1.2em;
      color: #D291BC;
      text-shadow: 2px 2px 8px rgba(210,145,188,0.6), 0 0 15px rgba(210,145,188,0.4);
      opacity: 0;
      transition: opacity 1.5s, transform 1.5s;
      text-align: center; padding: 10px;
      pointer-events: none;
      user-select: none;
    }
    #message.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
    }
  </style>
</head>
<body>
  <canvas id="bgCanvas"></canvas>
  <canvas id="gameCanvas"></canvas>
  <div id="message"></div>

  <script>
    // Retina & resize handling
    const bgCanvas = document.getElementById('bgCanvas'),
          gameCanvas = document.getElementById('gameCanvas'),
          bgCtx = bgCanvas.getContext('2d'),
          ctx   = gameCanvas.getContext('2d');
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      const w = window.innerWidth;
      const h = window.innerHeight;
      [bgCanvas, gameCanvas].forEach(c => {
        c.width  = w * dpr;
        c.height = h * dpr;
        c.style.width  = w + 'px';
        c.style.height = h + 'px';
        c.getContext('2d').scale(dpr, dpr);
      });
      basket.x = w/2 - basket.w/2;
      basket.y = h - basket.h - h*0.2;
      basket.targetX = basket.x;
    }
    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', ()=> setTimeout(resize,300));
    resize();

    // --- Ğ¤Ğ¾Ğ½Ğ¾Ğ²Ñ‹Ğµ Ñ†Ğ²ĞµÑ‚Ğ¾Ñ‡ĞºĞ¸ ---
    const flowerEmojis = ["ğŸŒ¸","ğŸŒ¼","ğŸŒº","ğŸŒ»","ğŸŒ·","ğŸ’","ğŸµï¸","ğŸŒ¹","ğŸŒ±","ğŸŒ¿"];
    let bgItems = [];
    for (let i = 0; i < 40; i++) {
      const base = 20 + Math.random()*20;
      bgItems.push({
        x: Math.random()*innerWidth,
        y: Math.random()*innerHeight,
        size: base*1.3,
        opacity: Math.random(),
        fade: Math.random()*0.02 + 0.005,
        emoji: flowerEmojis[Math.floor(Math.random()*flowerEmojis.length)],
        speed: 0.27 + Math.random()*0.27
      });
    }
    function drawBackground(){
      bgCtx.clearRect(0,0,innerWidth,innerHeight);
      bgItems.forEach(item=>{
        bgCtx.globalAlpha = item.opacity;
        bgCtx.font = `${item.size}px sans-serif`;
        bgCtx.fillText(item.emoji, item.x, item.y);
        item.y += item.speed;
        if (item.y > innerHeight) item.y = -item.size;
        item.opacity += item.fade;
        if (item.opacity > 1 || item.opacity < 0.2) item.fade *= -1;
      });
    }

    // --- ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ğ¸Ğ³Ñ€Ğ° ---
    const scaleBasket = 1.3 * 1.1;
    const basket = {
      w: 120 * scaleBasket,
      h: 60  * scaleBasket,
      x: innerWidth/2 - (120*scaleBasket)/2,
      y: innerHeight - (120*scaleBasket) - innerHeight*0.2,
      targetX: 0
    };
    basket.targetX = basket.x;

    const heartEmojis = ["â¤ï¸","ğŸ’–","ğŸ’œ","ğŸ’›","ğŸ’š","ğŸ’™","ğŸ§¡","ğŸ¤","ğŸ’•","ğŸ’—","ğŸ’“"];
    let hearts = [], score = 0, consecutiveMiss = 0;
    let nextMessageAt = randomInRange(40,60);

    const successPhrases = [
      "Ğ¢Ñ‹ Ğ¼Ğ¾Ğ»Ğ¾Ğ´ĞµÑ†, Ğ’Ğ¸ĞºÑƒĞ»Ñ!",
      "Ğ¯ Ñ‚ĞµĞ±Ñ Ğ»ÑĞ±Ğ»Ñ, ÑĞ¾Ğ»Ğ½Ñ‹ÑˆĞºĞ¾!",
      "Ğ¢Ñ‹ ÑĞ¼Ğ¾Ğ¶ĞµÑˆÑŒ Ğ²ÑÑ‘, Ğ¼Ğ¸Ğ»Ğ°Ñ!",
      "Ğ¢Ñ‹ â€” ÑĞ°Ğ¼Ğ°Ñ Ğ»ÑƒÑ‡ÑˆĞ°Ñ!",
      "Ğ¡ Ñ‚Ğ¾Ğ±Ğ¾Ğ¹ Ñ ÑÑ‡Ğ°ÑÑ‚Ğ»Ğ¸Ğ² â¤ï¸",
      "ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ ĞºĞ»Ğ¸Ğº â€” Ğ²Ğ¾Ğ»ÑˆĞµĞ±ÑÑ‚Ğ²Ğ¾!",
      "Ğ¢Ñ‹ Ğ´Ğ°Ñ€Ğ¸ÑˆÑŒ Ğ¼Ğ½Ğµ Ñ€Ğ°Ğ´Ğ¾ÑÑ‚ÑŒ!",
      "Ğ’ĞµĞ»Ğ¸ĞºĞ¾Ğ»ĞµĞ¿Ğ½Ğ¾, Ğ’Ğ¸ĞºÑƒĞ»Ñ!",
      "Ğ¢Ñ‹ Ğ¼Ğ¾Ñ Ğ·Ğ²ĞµĞ·Ğ´Ğ°!",
      "Ğ¢Ñ‹ ÑƒĞºÑ€Ğ°ÑˆĞ°ĞµÑˆÑŒ Ğ¼Ğ¾Ğ¹ Ğ´ĞµĞ½ÑŒ!"
    ];
    const missPhrases = [
      "Ğ£ÑĞºĞ¾Ğ»ÑŒĞ·Ğ½ÑƒĞ»Ğ° Ğ»ÑĞ±Ğ¾Ğ²ÑŒâ€¦ ğŸ¥º",
      "ĞĞ¹, ÑĞµÑ€Ğ´Ñ†Ğµ ÑƒÑĞºĞ¾Ğ»ÑŒĞ·Ğ½ÑƒĞ»Ğ¾!",
      "ĞĞµ Ñ€Ğ°ÑÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°Ğ¹ÑÑ, Ğ’Ğ¸ĞºÑƒĞ»Ñ!",
      "ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ğ¼Ğ°Ñ… â€” ÑÑ‚Ğ¾ Ğ¾Ğ¿Ñ‹Ñ‚!",
      "ĞĞµ Ğ³Ñ€ÑƒÑÑ‚Ğ¸, Ğ’Ğ¸ĞºÑƒĞ»Ñ, ĞµÑ‰Ñ‘ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ ÑˆĞ°Ğ½ÑĞ¾Ğ²!",
      "ĞĞµ ÑĞ´Ğ°Ğ²Ğ°Ğ¹ÑÑ, Ğ´Ğ°Ğ»ÑŒÑˆĞµ Ğ¿Ğ¾Ğ²ĞµĞ·Ñ‘Ñ‚!",
      "ĞÑ‚ Ğ¼Ğ¾ĞµĞ¹ Ğ»ÑĞ±Ğ²Ğ¸ Ğ½Ğµ ÑƒĞ±ĞµĞ¶Ğ°Ñ‚ÑŒ!",
      "Ğ›Ğ¾Ğ²Ğ¸Ğ¼ Ğ´Ğ°Ğ»ÑŒÑˆĞµ, ÑĞ¾Ğ»Ğ½Ñ‹ÑˆĞºĞ¾!",
      "ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ Ğ½Ğ° ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ñ€Ğ°Ğ·!",
      "ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°ĞµĞ¼ Ğ»Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑĞµÑ€Ğ´ĞµÑ‡ĞºĞ¸!"
    ];

    function randomInRange(min,max){
      return Math.floor(Math.random()*(max-min+1))+min;
    }

    function spawnHeart(){
      const size = 36 * 1.3;
      hearts.push({
        x: Math.random()*(innerWidth - size),
        y: -size,
        size,
        speed: (2 + Math.random()*2)*0.9,
        emoji: heartEmojis[Math.floor(Math.random()*heartEmojis.length)]
      });
    }

    function drawBasket(){
      ctx.font = `${60*scaleBasket}px sans-serif`;
      ctx.fillText("ğŸ§º", basket.x, basket.y + basket.h);
    }
    function drawHearts(){
      hearts.forEach(h=>{
        ctx.font = `${h.size}px sans-serif`;
        ctx.fillText(h.emoji, h.x, h.y);
      });
    }

    function updateHearts(){
      for (let i = hearts.length-1; i >= 0; i--){
        const h = hearts[i];
        h.y += h.speed;
        if (h.y > innerHeight + h.size){
          hearts.splice(i,1);
          consecutiveMiss++;
          if (consecutiveMiss >= 5){
            showMessage(missPhrases);
            consecutiveMiss = 0;
          }
        }
      }
    }

    function checkCatch(){
      for (let i = hearts.length-1; i >= 0; i--){
        const h = hearts[i];
        if (h.x > basket.x - 20 && h.x < basket.x + basket.w &&
            h.y > basket.y - 20 && h.y < basket.y + basket.h){
          hearts.splice(i,1);
          score++;
          consecutiveMiss = 0;
          if (score >= nextMessageAt){
            showMessage(successPhrases);
            nextMessageAt = score + randomInRange(40,60);
          }
        }
      }
    }

    function moveBasket(){
      basket.x += (basket.targetX - basket.x)*0.15;
    }

    function showMessage(arr){
      const msg = document.getElementById('message');
      msg.textContent = arr[Math.floor(Math.random()*arr.length)];
      msg.style.fontSize = '1.2em';
      msg.classList.add('show');
      setTimeout(()=> msg.classList.remove('show'), 2000);
    }

    function gameLoop(){
      drawBackground();
      ctx.clearRect(0,0,innerWidth,innerHeight);
      moveBasket(); drawBasket(); drawHearts();
      updateHearts(); checkCatch();
      ctx.font = "20px 'Press Start 2P', cursive";
      ctx.fillStyle = "#D291BC";
      ctx.fillText(`ğŸ’– ${score}`,20,40);
      requestAnimationFrame(gameLoop);
    }

    setInterval(spawnHeart,800);
    gameLoop();

    // Touch & mouse
    gameCanvas.addEventListener('mousemove', e=> basket.targetX = e.clientX - basket.w/2);
    gameCanvas.addEventListener('touchmove', e=> basket.targetX = e.touches[0].clientX - basket.w/2);
  </script>
</body>
</html>
